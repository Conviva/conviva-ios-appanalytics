// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target x86_64-apple-tvos12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ConvivaAppAnalytics
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CommonCrypto
@_exported import ConvivaAppAnalytics
import Dispatch
import Foundation
import Network
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
import zlib
@available(iOS 13.0, tvOS 16.0, *)
extension SwiftUI.Button {
  public func convivaAnalyticsButtonClick(title: Swift.String) -> some SwiftUI.View
  
}
public protocol CATCompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
public protocol CATEngineDelegate : AnyObject {
  func didReceive(event: ConvivaAppAnalytics.CATWebSocketEvent)
}
public protocol CATEngine {
  func register(delegate: ConvivaAppAnalytics.CATEngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: ConvivaAppAnalytics.CATFrameOpCode, completion: (() -> ())?)
  func write(string: Swift.String, completion: (() -> ())?)
}
public class CATFoundationHTTPHandler : ConvivaAppAnalytics.CATHTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: ConvivaAppAnalytics.CATHTTPHandlerDelegate)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CATFoundationHTTPServerHandler : ConvivaAppAnalytics.CATHTTPServerHandler {
  public func register(delegate: ConvivaAppAnalytics.CATHTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public enum CATFoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: ConvivaAppAnalytics.CATFoundationSecurityError, b: ConvivaAppAnalytics.CATFoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class CATFoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension ConvivaAppAnalytics.CATFoundationSecurity : ConvivaAppAnalytics.CATCertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((ConvivaAppAnalytics.CATPinningState) -> ()))
}
extension ConvivaAppAnalytics.CATFoundationSecurity : ConvivaAppAnalytics.CATHeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public enum CATFoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: ConvivaAppAnalytics.CATFoundationTransportError, b: ConvivaAppAnalytics.CATFoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class CATFoundationTransport : ObjectiveC.NSObject, ConvivaAppAnalytics.CATTransport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: ConvivaAppAnalytics.CATCertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: ConvivaAppAnalytics.CATTransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
public protocol CATFrameCollectorDelegate : AnyObject {
  func didForm(event: ConvivaAppAnalytics.CATFrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class CATFrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: ConvivaAppAnalytics.CATFrame)
  @objc deinit
}
public enum CATCloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum CATFrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct CATFrame {
}
public enum CATFrameEvent {
  case frame(ConvivaAppAnalytics.CATFrame)
  case error(Swift.Error)
}
public protocol CATFramerEventClient : AnyObject {
  func frameProcessed(event: ConvivaAppAnalytics.CATFrameEvent)
}
public protocol CATFramer {
  func add(data: Foundation.Data)
  func register(delegate: ConvivaAppAnalytics.CATFramerEventClient)
  func createWriteFrame(opcode: ConvivaAppAnalytics.CATFrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class CATWSFramer : ConvivaAppAnalytics.CATFramer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: ConvivaAppAnalytics.CATFramerEventClient)
  public func createWriteFrame(opcode: ConvivaAppAnalytics.CATFrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol CATMyWSArrayType {
}
extension Swift.UInt8 : ConvivaAppAnalytics.CATMyWSArrayType {
}
extension Swift.Array where Element : ConvivaAppAnalytics.CATMyWSArrayType, Element : Swift.UnsignedInteger {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
public enum CATHTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int, [Swift.String : Swift.String])
  case invalidData
}
public struct CATHTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum CATHTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(Swift.Error)
}
public protocol CATHTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: ConvivaAppAnalytics.CATHTTPEvent)
}
public protocol CATHTTPHandler {
  func register(delegate: ConvivaAppAnalytics.CATHTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol CATHTTPServerDelegate : AnyObject {
  func didReceive(event: ConvivaAppAnalytics.CATHTTPEvent)
}
public protocol CATHTTPServerHandler {
  func register(delegate: ConvivaAppAnalytics.CATHTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct CATURLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> ConvivaAppAnalytics.CATURLParts?
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class CATNativeEngine : ObjectiveC.NSObject, ConvivaAppAnalytics.CATEngine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: ConvivaAppAnalytics.CATEngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: ConvivaAppAnalytics.CATFrameOpCode, completion: (() -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @objc override dynamic public init()
  @objc deinit
}
public enum CATSecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum CATPinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CATCertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((ConvivaAppAnalytics.CATPinningState) -> ()))
}
public protocol CATHeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public enum CATConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error)
}
public protocol CATConnection {
  func write(data: Foundation.Data, opcode: ConvivaAppAnalytics.CATFrameOpCode)
}
public protocol CATConnectionDelegate : AnyObject {
  func didReceive(event: ConvivaAppAnalytics.CATServerEvent)
}
public enum CATServerEvent {
  case connected(ConvivaAppAnalytics.CATConnection, [Swift.String : Swift.String])
  case disconnected(ConvivaAppAnalytics.CATConnection, Swift.String, Swift.UInt16)
  case text(ConvivaAppAnalytics.CATConnection, Swift.String)
  case binary(ConvivaAppAnalytics.CATConnection, Foundation.Data)
  case pong(ConvivaAppAnalytics.CATConnection, Foundation.Data?)
  case ping(ConvivaAppAnalytics.CATConnection, Foundation.Data?)
}
public protocol CATServer {
  func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
}
@objc final public class CATSocketAckEmitter : ObjectiveC.NSObject {
  @objc final public var rawEmitView: ConvivaAppAnalytics.CATSocketRawAckView {
    @objc get
  }
  final public var expected: Swift.Bool {
    get
  }
  public init(socket: ConvivaAppAnalytics.CATSocketIOClient, ackNum: Swift.Int)
  final public func with(_ items: ConvivaAppAnalytics.CATSocketData...)
  @objc final public func with(_ items: [Any])
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class CATOnAckCallback : ObjectiveC.NSObject {
  @objc deinit
  @objc final public func timingOut(after seconds: Swift.Double, callback: @escaping ConvivaAppAnalytics.CATAckCallback)
}
public enum CATSocketAckStatus : Swift.String {
  case noAck
  public static func == (lhs: Swift.String, rhs: ConvivaAppAnalytics.CATSocketAckStatus) -> Swift.Bool
  public static func == (lhs: ConvivaAppAnalytics.CATSocketAckStatus, rhs: Swift.String) -> Swift.Bool
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers final public class CATSocketAnyEvent : ObjectiveC.NSObject {
  @objc final public let event: Swift.String
  @objc final public let items: [Any]?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
@objc open class CATSocketEngine : ObjectiveC.NSObject, ConvivaAppAnalytics.CATWebSocketDelegate, Foundation.URLSessionDelegate, ConvivaAppAnalytics.CATSocketEnginePollable, ConvivaAppAnalytics.CATSocketEngineWebsocket, ConvivaAppAnalytics.CATConfigSettable {
  final public let engineQueue: Dispatch.DispatchQueue
  public var connectParams: [Swift.String : Any]? {
    get
    set
  }
  public var extraHeaders: [Swift.String : Swift.String]?
  public var postWait: [ConvivaAppAnalytics.CATPost]
  public var waitingForPoll: Swift.Bool
  public var waitingForPost: Swift.Bool
  public var closed: Swift.Bool {
    get
  }
  public var compress: Swift.Bool {
    get
  }
  public var connected: Swift.Bool {
    get
  }
  public var cookies: [Foundation.HTTPCookie]? {
    get
  }
  public var fastUpgrade: Swift.Bool {
    get
  }
  public var forcePolling: Swift.Bool {
    get
  }
  public var forceWebsockets: Swift.Bool {
    get
  }
  public var invalidated: Swift.Bool {
    get
  }
  public var polling: Swift.Bool {
    get
  }
  public var probing: Swift.Bool {
    get
  }
  public var session: Foundation.URLSession? {
    get
  }
  public var sid: Swift.String {
    get
  }
  public var socketPath: Swift.String {
    get
  }
  public var urlPolling: Foundation.URL {
    get
  }
  public var urlWebSocket: Foundation.URL {
    get
  }
  public var useCustomEngine: Swift.Bool {
    get
  }
  public var version: ConvivaAppAnalytics.CATSocketIOVersion {
    get
  }
  @available(*, deprecated, message: "No longer needed, if we're not polling, then we must be doing websockets")
  public var websocket: Swift.Bool {
    get
  }
  public var enableSOCKSProxy: Swift.Bool {
    get
  }
  public var ws: ConvivaAppAnalytics.CATWebSocket? {
    get
  }
  public var wsConnected: Swift.Bool {
    get
  }
  weak public var client: ConvivaAppAnalytics.CATSocketEngineClient?
  public init(client: ConvivaAppAnalytics.CATSocketEngineClient, url: Foundation.URL, config: ConvivaAppAnalytics.CATSocketIOClientConfiguration)
  required convenience public init(client: ConvivaAppAnalytics.CATSocketEngineClient, url: Foundation.URL, options: [Swift.String : Any]?)
  @objc deinit
  open func connect()
  open func didError(reason: Swift.String)
  open func disconnect(reason: Swift.String)
  open func doFastUpgrade()
  open func flushWaitingForPostToWebSocket()
  open func parseEngineData(_ data: Foundation.Data)
  open func parseEngineMessage(_ message: Swift.String)
  open func setConfigs(_ config: ConvivaAppAnalytics.CATSocketIOClientConfiguration)
  open func write(_ msg: Swift.String, withType type: ConvivaAppAnalytics.CATSocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())? = nil)
}
extension ConvivaAppAnalytics.CATSocketEngine {
  public func URLSession(session: Foundation.URLSession, didBecomeInvalidWithError error: Foundation.NSError?)
}
extension ConvivaAppAnalytics.CATSocketEngine {
  public func didReceive(event: ConvivaAppAnalytics.CATWebSocketEvent, client: ConvivaAppAnalytics.CATWebSocketClient)
}
@objc public protocol CATSocketEngineClient {
  @objc func engineDidError(reason: Swift.String)
  @objc func engineDidClose(reason: Swift.String)
  @objc func engineDidOpen(reason: Swift.String)
  @objc func engineDidReceivePing()
  @objc func engineDidReceivePong()
  @objc func engineDidSendPing()
  @objc func engineDidSendPong()
  @objc func parseEngineMessage(_ msg: Swift.String)
  @objc func parseEngineBinaryData(_ data: Foundation.Data)
  @objc func engineDidWebsocketUpgrade(headers: [Swift.String : Swift.String])
}
@objc public enum CATSocketEnginePacketType : Swift.Int {
  case open
  case close
  case ping
  case pong
  case message
  case upgrade
  case noop
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol CATSocketEnginePollable : ConvivaAppAnalytics.CATSocketEngineSpec {
  var invalidated: Swift.Bool { get }
  var postWait: [ConvivaAppAnalytics.CATPost] { get set }
  var session: Foundation.URLSession? { get }
  var waitingForPoll: Swift.Bool { get set }
  var waitingForPost: Swift.Bool { get set }
  func doPoll()
  func sendPollMessage(_ message: Swift.String, withType type: ConvivaAppAnalytics.CATSocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())?)
  func stopPolling()
}
extension ConvivaAppAnalytics.CATSocketEnginePollable {
  public func doPoll()
  public func sendPollMessage(_ message: Swift.String, withType type: ConvivaAppAnalytics.CATSocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())? = nil)
  public func stopPolling()
}
public protocol CATSocketEngineSpec : AnyObject {
  var client: ConvivaAppAnalytics.CATSocketEngineClient? { get set }
  var closed: Swift.Bool { get }
  var compress: Swift.Bool { get }
  var connected: Swift.Bool { get }
  var connectParams: [Swift.String : Any]? { get set }
  var cookies: [Foundation.HTTPCookie]? { get }
  var engineQueue: Dispatch.DispatchQueue { get }
  var extraHeaders: [Swift.String : Swift.String]? { get set }
  var fastUpgrade: Swift.Bool { get }
  var forcePolling: Swift.Bool { get }
  var forceWebsockets: Swift.Bool { get }
  var polling: Swift.Bool { get }
  var probing: Swift.Bool { get }
  var sid: Swift.String { get }
  var socketPath: Swift.String { get }
  var urlPolling: Foundation.URL { get }
  var urlWebSocket: Foundation.URL { get }
  var version: ConvivaAppAnalytics.CATSocketIOVersion { get }
  @available(*, deprecated, message: "No longer needed, if we're not polling, then we must be doing websockets")
  var websocket: Swift.Bool { get }
  var ws: ConvivaAppAnalytics.CATWebSocket? { get }
  init(client: ConvivaAppAnalytics.CATSocketEngineClient, url: Foundation.URL, options: [Swift.String : Any]?)
  func connect()
  func didError(reason: Swift.String)
  func disconnect(reason: Swift.String)
  func doFastUpgrade()
  func flushWaitingForPostToWebSocket()
  func parseEngineData(_ data: Foundation.Data)
  func parseEngineMessage(_ message: Swift.String)
  func write(_ msg: Swift.String, withType type: ConvivaAppAnalytics.CATSocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())?)
}
public protocol CATSocketEngineWebsocket : ConvivaAppAnalytics.CATSocketEngineSpec {
  var wsConnected: Swift.Bool { get }
  func sendWebSocketMessage(_ str: Swift.String, withType type: ConvivaAppAnalytics.CATSocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())?)
}
extension ConvivaAppAnalytics.CATSocketEngineWebsocket {
  public func sendWebSocketMessage(_ str: Swift.String, withType type: ConvivaAppAnalytics.CATSocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())?)
}
public struct CATSocketEventHandler {
  public let event: Swift.String
  public let id: Foundation.UUID
  public let callback: ConvivaAppAnalytics.CATNormalCallback
  public func executeCallback(with items: [Any], withAck ack: Swift.Int, withSocket socket: ConvivaAppAnalytics.CATSocketIOClient)
}
@objc open class CATSocketIOClient : ObjectiveC.NSObject, ConvivaAppAnalytics.CATSocketIOClientSpec {
  final public let nsp: Swift.String
  public var anyHandler: ((ConvivaAppAnalytics.CATSocketAnyEvent) -> ())? {
    get
  }
  public var handlers: [ConvivaAppAnalytics.CATSocketEventHandler] {
    get
  }
  weak public var manager: ConvivaAppAnalytics.CATSocketManagerSpec? {
    get
  }
  public var rawEmitView: ConvivaAppAnalytics.CATSocketRawView {
    get
  }
  public var status: ConvivaAppAnalytics.CATSocketIOStatus {
    get
  }
  public var sid: Swift.String? {
    get
  }
  public init(manager: ConvivaAppAnalytics.CATSocketManagerSpec, nsp: Swift.String)
  @objc deinit
  open func connect(withPayload payload: [Swift.String : Any]? = nil)
  open func connect(withPayload payload: [Swift.String : Any]? = nil, timeoutAfter: Swift.Double, withHandler handler: (() -> ())?)
  open func didConnect(toNamespace namespace: Swift.String, payload: [Swift.String : Any]?)
  open func didDisconnect(reason: Swift.String)
  open func disconnect()
  open func emit(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData..., completion: (() -> ())? = nil)
  open func emit(_ event: Swift.String, with items: [ConvivaAppAnalytics.CATSocketData], completion: (() -> ())?)
  open func emitWithAck(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData...) -> ConvivaAppAnalytics.CATOnAckCallback
  open func emitWithAck(_ event: Swift.String, with items: [ConvivaAppAnalytics.CATSocketData]) -> ConvivaAppAnalytics.CATOnAckCallback
  open func emitAck(_ ack: Swift.Int, with items: [Any])
  open func handleAck(_ ack: Swift.Int, data: [Any])
  open func handleClientEvent(_ event: ConvivaAppAnalytics.CATSocketClientEvent, data: [Any])
  open func handleEvent(_ event: Swift.String, data: [Any], isInternalMessage: Swift.Bool, withAck ack: Swift.Int = -1)
  open func handlePacket(_ packet: ConvivaAppAnalytics.CATSocketPacket)
  open func leaveNamespace()
  open func joinNamespace(withPayload payload: [Swift.String : Any]? = nil)
  open func off(clientEvent event: ConvivaAppAnalytics.CATSocketClientEvent)
  open func off(_ event: Swift.String)
  open func off(id: Foundation.UUID)
  @discardableResult
  open func on(_ event: Swift.String, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  @discardableResult
  open func on(clientEvent event: ConvivaAppAnalytics.CATSocketClientEvent, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  @discardableResult
  open func once(clientEvent event: ConvivaAppAnalytics.CATSocketClientEvent, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  @discardableResult
  open func once(_ event: Swift.String, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  open func onAny(_ handler: @escaping (ConvivaAppAnalytics.CATSocketAnyEvent) -> ())
  @available(*, unavailable, message: "Call the manager's reconnect method")
  open func reconnect()
  open func removeAllHandlers()
  open func setReconnecting(reason: Swift.String)
}
public struct CATSocketIOClientConfiguration : Swift.ExpressibleByArrayLiteral, Swift.Collection, Swift.MutableCollection {
  public typealias Element = ConvivaAppAnalytics.CATSocketIOClientOption
  public typealias Index = Swift.Array<ConvivaAppAnalytics.CATSocketIOClientOption>.Index
  public typealias Iterator = Swift.Array<ConvivaAppAnalytics.CATSocketIOClientOption>.Iterator
  public typealias SubSequence = Swift.Array<ConvivaAppAnalytics.CATSocketIOClientOption>.SubSequence
  public var startIndex: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Index {
    get
  }
  public var endIndex: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Index {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Index.Stride {
    get
  }
  public var first: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Element? {
    get
  }
  public subscript(position: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Index) -> ConvivaAppAnalytics.CATSocketIOClientConfiguration.Element {
    get
    set
  }
  public subscript(bounds: Swift.Range<ConvivaAppAnalytics.CATSocketIOClientConfiguration.Index>) -> ConvivaAppAnalytics.CATSocketIOClientConfiguration.SubSequence {
    get
    set
  }
  public init(arrayLiteral elements: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Element...)
  public func makeIterator() -> ConvivaAppAnalytics.CATSocketIOClientConfiguration.Iterator
  public func index(after i: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Index) -> ConvivaAppAnalytics.CATSocketIOClientConfiguration.Index
  public mutating func insert(_ element: ConvivaAppAnalytics.CATSocketIOClientConfiguration.Element, replacing replace: Swift.Bool = true)
  public typealias ArrayLiteralElement = ConvivaAppAnalytics.CATSocketIOClientConfiguration.Element
  public typealias Indices = Swift.DefaultIndices<ConvivaAppAnalytics.CATSocketIOClientConfiguration>
}
public protocol CATConfigSettable {
  mutating func setConfigs(_ config: ConvivaAppAnalytics.CATSocketIOClientConfiguration)
}
public enum CATSocketIOVersion : Swift.Int {
  case two
  case three
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum CATSocketIOClientOption {
  case compress
  case connectParams([Swift.String : Any])
  case cookies([Foundation.HTTPCookie])
  case extraHeaders([Swift.String : Swift.String])
  case forceNew(Swift.Bool)
  case forcePolling(Swift.Bool)
  case forceWebsockets(Swift.Bool)
  case enableSOCKSProxy(Swift.Bool)
  case handleQueue(Dispatch.DispatchQueue)
  case log(Swift.Bool)
  case logger(ConvivaAppAnalytics.CATSocketLogger)
  case path(Swift.String)
  case reconnects(Swift.Bool)
  case reconnectAttempts(Swift.Int)
  case reconnectWait(Swift.Int)
  case reconnectWaitMax(Swift.Int)
  case randomizationFactor(Swift.Double)
  case secure(Swift.Bool)
  case security(ConvivaAppAnalytics.CATCertificatePinning)
  case selfSigned(Swift.Bool)
  case sessionDelegate(Foundation.URLSessionDelegate)
  case useCustomEngine(Swift.Bool)
  case version(ConvivaAppAnalytics.CATSocketIOVersion)
  public var description: Swift.String {
    get
  }
  public static func == (lhs: ConvivaAppAnalytics.CATSocketIOClientOption, rhs: ConvivaAppAnalytics.CATSocketIOClientOption) -> Swift.Bool
}
public protocol CATSocketIOClientSpec : AnyObject {
  var anyHandler: ((ConvivaAppAnalytics.CATSocketAnyEvent) -> ())? { get }
  var handlers: [ConvivaAppAnalytics.CATSocketEventHandler] { get }
  var manager: ConvivaAppAnalytics.CATSocketManagerSpec? { get }
  var nsp: Swift.String { get }
  var rawEmitView: ConvivaAppAnalytics.CATSocketRawView { get }
  var sid: Swift.String? { get }
  var status: ConvivaAppAnalytics.CATSocketIOStatus { get }
  func connect(withPayload payload: [Swift.String : Any]?)
  func connect(withPayload payload: [Swift.String : Any]?, timeoutAfter: Swift.Double, withHandler handler: (() -> ())?)
  func didConnect(toNamespace namespace: Swift.String, payload: [Swift.String : Any]?)
  func didDisconnect(reason: Swift.String)
  func didError(reason: Swift.String)
  func disconnect()
  func emit(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData..., completion: (() -> ())?)
  func emit(_ event: Swift.String, with items: [ConvivaAppAnalytics.CATSocketData], completion: (() -> ())?)
  func emitAck(_ ack: Swift.Int, with items: [Any])
  func emitWithAck(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData...) -> ConvivaAppAnalytics.CATOnAckCallback
  func emitWithAck(_ event: Swift.String, with items: [ConvivaAppAnalytics.CATSocketData]) -> ConvivaAppAnalytics.CATOnAckCallback
  func handleAck(_ ack: Swift.Int, data: [Any])
  func handleClientEvent(_ event: ConvivaAppAnalytics.CATSocketClientEvent, data: [Any])
  func handleEvent(_ event: Swift.String, data: [Any], isInternalMessage: Swift.Bool, withAck ack: Swift.Int)
  func handlePacket(_ packet: ConvivaAppAnalytics.CATSocketPacket)
  func leaveNamespace()
  func joinNamespace(withPayload payload: [Swift.String : Any]?)
  func off(clientEvent event: ConvivaAppAnalytics.CATSocketClientEvent)
  func off(_ event: Swift.String)
  func off(id: Foundation.UUID)
  func on(_ event: Swift.String, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  func on(clientEvent event: ConvivaAppAnalytics.CATSocketClientEvent, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  func once(clientEvent event: ConvivaAppAnalytics.CATSocketClientEvent, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  func once(_ event: Swift.String, callback: @escaping ConvivaAppAnalytics.CATNormalCallback) -> Foundation.UUID
  func onAny(_ handler: @escaping (ConvivaAppAnalytics.CATSocketAnyEvent) -> ())
  func removeAllHandlers()
  func setReconnecting(reason: Swift.String)
}
extension ConvivaAppAnalytics.CATSocketIOClientSpec {
  public func didError(reason: Swift.String)
}
public enum CATSocketClientEvent : Swift.String {
  case connect
  case disconnect
  case error
  case ping
  case pong
  case reconnect
  case reconnectAttempt
  case statusChange
  case websocketUpgrade
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum CATSocketIOStatus : Swift.Int, Swift.CustomStringConvertible {
  case notConnected
  case disconnected
  case connecting
  case connected
  public var active: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol CATSocketLogger : AnyObject {
  var log: Swift.Bool { get set }
  func log(_ message: @autoclosure () -> Swift.String, type: Swift.String)
  func error(_ message: @autoclosure () -> Swift.String, type: Swift.String)
}
extension ConvivaAppAnalytics.CATSocketLogger {
  public func log(_ message: @autoclosure () -> Swift.String, type: Swift.String)
  public func error(_ message: @autoclosure () -> Swift.String, type: Swift.String)
}
@objc open class CATSocketManager : ObjectiveC.NSObject, ConvivaAppAnalytics.CATSocketManagerSpec, ConvivaAppAnalytics.CATSocketParsable, ConvivaAppAnalytics.CATSocketDataBufferable, ConvivaAppAnalytics.CATConfigSettable {
  public var defaultSocket: ConvivaAppAnalytics.CATSocketIOClient {
    get
  }
  final public let socketURL: Foundation.URL
  public var config: ConvivaAppAnalytics.CATSocketIOClientConfiguration {
    get
    set
  }
  public var engine: ConvivaAppAnalytics.CATSocketEngineSpec?
  public var forceNew: Swift.Bool
  public var handleQueue: Dispatch.DispatchQueue
  public var nsps: [Swift.String : ConvivaAppAnalytics.CATSocketIOClient]
  public var reconnects: Swift.Bool
  public var reconnectWait: Swift.Int
  public var reconnectWaitMax: Swift.Int
  public var randomizationFactor: Swift.Double
  public var status: ConvivaAppAnalytics.CATSocketIOStatus {
    get
  }
  public var version: ConvivaAppAnalytics.CATSocketIOVersion {
    get
  }
  public var waitingPackets: [ConvivaAppAnalytics.CATSocketPacket]
  public init(socketURL: Foundation.URL, config: ConvivaAppAnalytics.CATSocketIOClientConfiguration = [])
  @objc convenience public init(socketURL: Foundation.URL, config: [Swift.String : Any]?)
  @objc deinit
  open func connect()
  open func connectSocket(_ socket: ConvivaAppAnalytics.CATSocketIOClient, withPayload payload: [Swift.String : Any]? = nil)
  open func didDisconnect(reason: Swift.String)
  open func disconnect()
  open func disconnectSocket(_ socket: ConvivaAppAnalytics.CATSocketIOClient)
  open func disconnectSocket(forNamespace nsp: Swift.String)
  open func emitAll(clientEvent event: ConvivaAppAnalytics.CATSocketClientEvent, data: [Any])
  open func emitAll(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData...)
  @objc open func engineDidClose(reason: Swift.String)
  @objc open func engineDidError(reason: Swift.String)
  @objc open func engineDidOpen(reason: Swift.String)
  @objc open func engineDidReceivePing()
  @objc open func engineDidSendPing()
  @objc open func engineDidReceivePong()
  @objc open func engineDidSendPong()
  @objc open func engineDidWebsocketUpgrade(headers: [Swift.String : Swift.String])
  @objc open func parseEngineMessage(_ msg: Swift.String)
  @objc open func parseEngineBinaryData(_ data: Foundation.Data)
  open func reconnect()
  @discardableResult
  open func removeSocket(_ socket: ConvivaAppAnalytics.CATSocketIOClient) -> ConvivaAppAnalytics.CATSocketIOClient?
  open func setConfigs(_ config: ConvivaAppAnalytics.CATSocketIOClientConfiguration)
  open func socket(forNamespace nsp: Swift.String) -> ConvivaAppAnalytics.CATSocketIOClient
}
public protocol CATSocketManagerSpec : ConvivaAppAnalytics.CATSocketEngineClient {
  var defaultSocket: ConvivaAppAnalytics.CATSocketIOClient { get }
  var engine: ConvivaAppAnalytics.CATSocketEngineSpec? { get set }
  var forceNew: Swift.Bool { get set }
  var handleQueue: Dispatch.DispatchQueue { get set }
  var nsps: [Swift.String : ConvivaAppAnalytics.CATSocketIOClient] { get set }
  var reconnects: Swift.Bool { get set }
  var reconnectWait: Swift.Int { get set }
  var reconnectWaitMax: Swift.Int { get set }
  var randomizationFactor: Swift.Double { get set }
  var socketURL: Foundation.URL { get }
  var status: ConvivaAppAnalytics.CATSocketIOStatus { get }
  var version: ConvivaAppAnalytics.CATSocketIOVersion { get }
  func connect()
  func connectSocket(_ socket: ConvivaAppAnalytics.CATSocketIOClient, withPayload: [Swift.String : Any]?)
  func didDisconnect(reason: Swift.String)
  func disconnect()
  func disconnectSocket(_ socket: ConvivaAppAnalytics.CATSocketIOClient)
  func disconnectSocket(forNamespace nsp: Swift.String)
  func emitAll(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData...)
  func reconnect()
  @discardableResult
  func removeSocket(_ socket: ConvivaAppAnalytics.CATSocketIOClient) -> ConvivaAppAnalytics.CATSocketIOClient?
  func socket(forNamespace nsp: Swift.String) -> ConvivaAppAnalytics.CATSocketIOClient
}
public struct CATSocketPacket : Swift.CustomStringConvertible {
  public let nsp: Swift.String
  public let id: Swift.Int
  public let type: ConvivaAppAnalytics.CATSocketPacket.PacketType
  public var binary: [Foundation.Data] {
    get
  }
  public var data: [Any] {
    get
  }
  public var args: [Any] {
    get
  }
  public var description: Swift.String {
    get
  }
  public var event: Swift.String {
    get
  }
  public var packetString: Swift.String {
    get
  }
}
extension ConvivaAppAnalytics.CATSocketPacket {
  public enum PacketType : Swift.Int {
    case connect
    case disconnect
    case event
    case ack
    case error
    case binaryEvent
    case binaryAck
    public var isBinary: Swift.Bool {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
public protocol CATSocketParsable : AnyObject {
  func parseBinaryData(_ data: Foundation.Data) -> ConvivaAppAnalytics.CATSocketPacket?
  func parseSocketMessage(_ message: Swift.String) -> ConvivaAppAnalytics.CATSocketPacket?
}
public enum CATSocketParsableError : Swift.Error {
  case invalidDataArray
  case invalidPacket
  case invalidPacketType
  public static func == (a: ConvivaAppAnalytics.CATSocketParsableError, b: ConvivaAppAnalytics.CATSocketParsableError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CATSocketDataBufferable : AnyObject {
  var waitingPackets: [ConvivaAppAnalytics.CATSocketPacket] { get set }
}
extension ConvivaAppAnalytics.CATSocketParsable where Self : ConvivaAppAnalytics.CATSocketDataBufferable, Self : ConvivaAppAnalytics.CATSocketManagerSpec {
  public func parseSocketMessage(_ message: Swift.String) -> ConvivaAppAnalytics.CATSocketPacket?
  public func parseBinaryData(_ data: Foundation.Data) -> ConvivaAppAnalytics.CATSocketPacket?
}
@objc @_hasMissingDesignatedInitializers final public class CATSocketRawView : ObjectiveC.NSObject {
  final public func emit(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData...)
  @objc final public func emit(_ event: Swift.String, with items: [Any])
  final public func emitWithAck(_ event: Swift.String, _ items: ConvivaAppAnalytics.CATSocketData...) -> ConvivaAppAnalytics.CATOnAckCallback
  @objc final public func emitWithAck(_ event: Swift.String, with items: [Any]) -> ConvivaAppAnalytics.CATOnAckCallback
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class CATSocketRawAckView : ObjectiveC.NSObject {
  final public func with(_ items: ConvivaAppAnalytics.CATSocketData...)
  @objc final public func with(_ items: [Any])
  @objc deinit
}
public protocol CATSocketData {
  func socketRepresentation() throws -> ConvivaAppAnalytics.CATSocketData
}
extension ConvivaAppAnalytics.CATSocketData {
  public func socketRepresentation() -> ConvivaAppAnalytics.CATSocketData
}
extension Swift.Array : ConvivaAppAnalytics.CATSocketData {
}
extension Swift.Bool : ConvivaAppAnalytics.CATSocketData {
}
extension Swift.Dictionary : ConvivaAppAnalytics.CATSocketData {
}
extension Swift.Double : ConvivaAppAnalytics.CATSocketData {
}
extension Swift.Int : ConvivaAppAnalytics.CATSocketData {
}
extension Foundation.NSArray : ConvivaAppAnalytics.CATSocketData {
}
extension Foundation.Data : ConvivaAppAnalytics.CATSocketData {
}
extension Foundation.NSData : ConvivaAppAnalytics.CATSocketData {
}
extension Foundation.NSDictionary : ConvivaAppAnalytics.CATSocketData {
}
extension Foundation.NSString : ConvivaAppAnalytics.CATSocketData {
}
extension Foundation.NSNull : ConvivaAppAnalytics.CATSocketData {
}
extension Swift.String : ConvivaAppAnalytics.CATSocketData {
}
public typealias CATAckCallback = ([Any]) -> ()
public typealias CATNormalCallback = ([Any], ConvivaAppAnalytics.CATSocketAckEmitter) -> ()
public typealias CATPost = (msg: Swift.String, completion: (() -> ())?)
public class CATStringHTTPHandler : ConvivaAppAnalytics.CATHTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: ConvivaAppAnalytics.CATHTTPHandlerDelegate)
  @objc deinit
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: ConvivaAppAnalytics.TCPTransportError, b: ConvivaAppAnalytics.TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class CATTCPTransport : ConvivaAppAnalytics.CATTransport {
  @objc deinit
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: ConvivaAppAnalytics.CATCertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: ConvivaAppAnalytics.CATTransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
}
public enum CATConnectionState {
  case connected
  case waiting
  case cancelled
  case failed(Swift.Error?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
  case peerClosed
}
public protocol CATTransportEventClient : AnyObject {
  func connectionChanged(state: ConvivaAppAnalytics.CATConnectionState)
}
public protocol CATTransport : AnyObject {
  func register(delegate: ConvivaAppAnalytics.CATTransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: ConvivaAppAnalytics.CATCertificatePinning?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  var usingTLS: Swift.Bool { get }
}
public enum CATErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: ConvivaAppAnalytics.CATErrorType, b: ConvivaAppAnalytics.CATErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CATWSError : Swift.Error {
  public let type: ConvivaAppAnalytics.CATErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: ConvivaAppAnalytics.CATErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol CATWebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(stringData: Foundation.Data, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension ConvivaAppAnalytics.CATWebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum CATWebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
  case peerClosed
}
public protocol CATWebSocketDelegate : AnyObject {
  func didReceive(event: ConvivaAppAnalytics.CATWebSocketEvent, client: ConvivaAppAnalytics.CATWebSocketClient)
}
open class CATWebSocket : ConvivaAppAnalytics.CATWebSocketClient, ConvivaAppAnalytics.CATEngineDelegate {
  weak public var delegate: ConvivaAppAnalytics.CATWebSocketDelegate?
  public var onEvent: ((ConvivaAppAnalytics.CATWebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set
  }
  public init(request: Foundation.URLRequest, engine: ConvivaAppAnalytics.CATEngine)
  convenience public init(request: Foundation.URLRequest, certPinner: ConvivaAppAnalytics.CATCertificatePinning? = CATFoundationSecurity(), compressionHandler: ConvivaAppAnalytics.CATCompressionHandler? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CATCloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: (() -> ())?)
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(stringData: Foundation.Data, completion: (() -> ())?)
  public func write(ping: Foundation.Data, completion: (() -> ())?)
  public func write(pong: Foundation.Data, completion: (() -> ())?)
  public func didReceive(event: ConvivaAppAnalytics.CATWebSocketEvent)
  @objc deinit
}
@objc public protocol CATWebSocketManagerBridgeDelegate {
  @objc func socketDidConnect()
  @objc func socketDidDisconnect()
  @objc func socketDidReceive(event: Swift.String, data: [Any])
  @objc func socketDidReceiveError(_ error: Swift.Error?)
}
@objc public class CATWebSocketManagerBridge : ObjectiveC.NSObject {
  @objc weak public var delegate: ConvivaAppAnalytics.CATWebSocketManagerBridgeDelegate?
  @objc public init(socketURL: Foundation.URL, jwt: Swift.String)
  @objc deinit
  @objc public func connect()
  @objc public func connect(withPayload payload: [Swift.String : Any]?)
  @objc public func disconnect()
  @objc public func emitBinary(event: Swift.String, binaryData: Foundation.Data)
  @objc public func emitEventWithAck(_ event: Swift.String, completion: @escaping () -> Swift.Void)
  @objc public func isConnected() -> Swift.Bool
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class CATWebSocketServer : ConvivaAppAnalytics.CATServer, ConvivaAppAnalytics.CATConnectionDelegate {
  public var onEvent: ((ConvivaAppAnalytics.CATServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
  public func didReceive(event: ConvivaAppAnalytics.CATServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class CATServerConnection : ConvivaAppAnalytics.CATConnection, ConvivaAppAnalytics.CATHTTPServerDelegate, ConvivaAppAnalytics.CATFramerEventClient, ConvivaAppAnalytics.CATFrameCollectorDelegate, ConvivaAppAnalytics.CATTransportEventClient {
  public var onEvent: ((ConvivaAppAnalytics.CATConnectionEvent) -> Swift.Void)?
  weak public var delegate: ConvivaAppAnalytics.CATConnectionDelegate?
  public func write(data: Foundation.Data, opcode: ConvivaAppAnalytics.CATFrameOpCode)
  public func connectionChanged(state: ConvivaAppAnalytics.CATConnectionState)
  public func didReceive(event: ConvivaAppAnalytics.CATHTTPEvent)
  public func frameProcessed(event: ConvivaAppAnalytics.CATFrameEvent)
  public func didForm(event: ConvivaAppAnalytics.CATFrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
public class CATWSCompression : ConvivaAppAnalytics.CATCompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public class CATWSEngine : ConvivaAppAnalytics.CATEngine, ConvivaAppAnalytics.CATTransportEventClient, ConvivaAppAnalytics.CATFramerEventClient, ConvivaAppAnalytics.CATFrameCollectorDelegate, ConvivaAppAnalytics.CATHTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: ConvivaAppAnalytics.CATTransport, certPinner: ConvivaAppAnalytics.CATCertificatePinning? = nil, headerValidator: ConvivaAppAnalytics.CATHeaderValidator = CATFoundationSecurity(), httpHandler: ConvivaAppAnalytics.CATHTTPHandler = CATFoundationHTTPHandler(), framer: ConvivaAppAnalytics.CATFramer = CATWSFramer(), compressionHandler: ConvivaAppAnalytics.CATCompressionHandler? = nil)
  public func register(delegate: ConvivaAppAnalytics.CATEngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CATCloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: ConvivaAppAnalytics.CATFrameOpCode, completion: (() -> ())?)
  public func connectionChanged(state: ConvivaAppAnalytics.CATConnectionState)
  public func didReceiveHTTP(event: ConvivaAppAnalytics.CATHTTPEvent)
  public func frameProcessed(event: ConvivaAppAnalytics.CATFrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: ConvivaAppAnalytics.CATFrameCollector.Event)
  @objc deinit
}
@available(iOS 13.0, tvOS 13.0, *)
extension SwiftUI.View {
  public func convivaAnalyticsScreenView(name: Swift.String) -> some SwiftUI.View
  
}
extension ConvivaAppAnalytics.CATFoundationSecurityError : Swift.Equatable {}
extension ConvivaAppAnalytics.CATFoundationSecurityError : Swift.Hashable {}
extension ConvivaAppAnalytics.CATFoundationTransportError : Swift.Equatable {}
extension ConvivaAppAnalytics.CATFoundationTransportError : Swift.Hashable {}
extension ConvivaAppAnalytics.CATCloseCode : Swift.Equatable {}
extension ConvivaAppAnalytics.CATCloseCode : Swift.Hashable {}
extension ConvivaAppAnalytics.CATCloseCode : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATFrameOpCode : Swift.Equatable {}
extension ConvivaAppAnalytics.CATFrameOpCode : Swift.Hashable {}
extension ConvivaAppAnalytics.CATFrameOpCode : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSecurityErrorCode : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSecurityErrorCode : Swift.Hashable {}
extension ConvivaAppAnalytics.CATSecurityErrorCode : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSocketAckStatus : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketAckStatus : Swift.Hashable {}
extension ConvivaAppAnalytics.CATSocketAckStatus : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSocketEnginePacketType : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketEnginePacketType : Swift.Hashable {}
extension ConvivaAppAnalytics.CATSocketEnginePacketType : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSocketIOVersion : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketIOVersion : Swift.Hashable {}
extension ConvivaAppAnalytics.CATSocketIOVersion : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSocketIOClientOption : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketIOClientOption : Swift.CustomStringConvertible {}
extension ConvivaAppAnalytics.CATSocketClientEvent : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketClientEvent : Swift.Hashable {}
extension ConvivaAppAnalytics.CATSocketClientEvent : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSocketIOStatus : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketIOStatus : Swift.Hashable {}
extension ConvivaAppAnalytics.CATSocketIOStatus : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSocketPacket.PacketType : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketPacket.PacketType : Swift.Hashable {}
extension ConvivaAppAnalytics.CATSocketPacket.PacketType : Swift.RawRepresentable {}
extension ConvivaAppAnalytics.CATSocketParsableError : Swift.Equatable {}
extension ConvivaAppAnalytics.CATSocketParsableError : Swift.Hashable {}
extension ConvivaAppAnalytics.TCPTransportError : Swift.Equatable {}
extension ConvivaAppAnalytics.TCPTransportError : Swift.Hashable {}
extension ConvivaAppAnalytics.CATErrorType : Swift.Equatable {}
extension ConvivaAppAnalytics.CATErrorType : Swift.Hashable {}
